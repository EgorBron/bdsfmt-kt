# Сравнение BSON, BDSFmt и Protobuf

## BSON

Плюсы:
* динамическая структура
* расширяемые типы
* просто парсить

Минусы:
* самый большой размер

## BDSFmt

Плюсы:
* динамическая структура
* немного меньше BSON (особенно если использовать ItemID как ключи)
* (в случае моего парсера) удобное хранение данных любого размера, так как обозначение длины можно указывать и в UByte, и в BigInt

Минусы:
* Сложно добавить новые типы
  * в случае моего парсера их может быть всего 255 (0xFF) - 28 (стандартные типы) - 16 (зарезервированные) = 211, и они будут различны в разных системах
* Большинство типов данных не имеют ограничений по длине и должны оканчиваться на `0x00` (EOT)
* Программа для парса будет очень перегружена

## Protobuf

Плюсы:
* сверхкомпактный размер (так как записаны только данные)
* расширяемые типы
* просто парсить

Минусы:
* требуется задавать схему данных
* сложно (невозможно) хранить произвольные данные (не типа "объект в объекте")
* при утере схемы трудно декодировать (а минус ли это?)

## Референс

Вывод программы, сравнивающей длины данных со схемой ниже:
```
BDSF file length: 117, w/o header: 98
Comparing to BSON: 151
Comparing to Protobuf: 59
```

Для схемы был взят данный JSON:
```json5
{
    "titles": {
        "title": "Some title for the document",
        "mode" : [32, -8, 42]
    },
    "items": {
        "_0101010101010101": { // хотелось UUID8 с единицами, но BSON и Protobuf не "съедят" его как ключ
          "foo": "bar",
          "baz": "qux"
        }
    }
}
```

Protobuf:
```protobuf
syntax = "proto3";

message MessageFromJson {

  TitlesSubMsg titles = 1;
  ItemsSubMsg items = 2;

  message TitlesSubMsg {

    string title = 1;
    repeated int32 mode = 2;
  }

  message _0101010101010101SubMsg {

    string foo = 1;
    string baz = 2;
  }

  message ItemsSubMsg {

    _0101010101010101SubMsg _0101010101010101 = 1;
  }
}
```